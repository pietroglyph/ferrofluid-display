[{"categories":null,"contents":"Design Sprints The duration of the project was broken up into three two-week-long design sprints. At the end of each sprint, we presented our progress to the teaching team and our peers.\nContents:   Sprint One Sprint Two Sprint Three     Sprint One \u0026uarr;   Sprint One had three main objectives:\n Create a test tank Research magnets Ordering important materials and other important organizing tasks  Test Tank Creating the test tank had two subgoals: creating an \u0026ldquo;etch-a-sketch\u0026rdquo; where we were able to move metal shavings with an electromagnet and creating a water-tight tank.\nEtch-A-Sketch We were able to successfully create a small test tank that only had metal shavings in it. We used an electromagnet that had previously been purchased to prove that the metal shavings could be moved with an electromagnet. An image of the test tank is below.\nWater-Tight Tank Another goal with tank ideation was to begin thinking about what it would take to create a water-tight tank. At the start we knew that the finished product would have ferrofluid suspended in saline, so we had to be prepared to reach that goal.\nWhen we made the tank it was apparent that there were issues with leaking, a evidenced by salt build up on the outside of the tank from the saline inside. An image of the salt build up is below.\nAdditionally, we were unsure if we had successfully coated the tank to be hydrophobic. If the inside of the tank was not properly cleaned and coated, the ferrofluid would stick to the glass and stain it.\nMagnet Research We started this sprint by researching whether or not we should wind electromagnets by hand or buy them. We quickly ruled out buying electromagnets as it would be too expensive to buy the amount we wanted and we ruled out winding our own because of the time commitment it required.\nWound Electromagnet Research In our research, we realized that outright buying electromagnets would be too expensive. At the time we also discussed winding our own electromagnets, but ruled that out because of the time commitment and potentially having costs regarding wiring get out of hand.\nHowever, we did hand-wind a couple electromagnets to test if it was feasible. They were much weaker than our final magnets would be, but were an important test.\nDuring this sprint we settled on a different way to create an electromagnet: PCB coils.\nPCB Coil Electromagnets We designed and ordered PCB capable of creating an electromagnet. We believed our PCB electromagnets would have many advantages over traditional electromagnets: we could fit more \u0026ldquo;turns\u0026rdquo; in the wire in less space, power and control the magnets more easily, and we could cover more area of the tank. A picture of one of the finished magnet boards is below.\nWe designed and ordered the boards this sprint. Ideally they would work like a regular electromagnet - current would pass through the coils and magnetize a ferrous core in the middle of the turns. The plan was to cut small piece of a metal rod and slot them into the holes in the PCB.\nOrganization We made important organizational leaps during this sprint as well: we ordered the ferrofluid, we placed a Home Depot order with many crucial items, and we created a Notion board to delegate tasks.\nThe ferrofluid arrived at the very end of sprint one, so we were able to begin preliminary tests with it immediately. We ordered glass for a larger tank, epoxy, and a metal rod (ferrous core for the magnets) from Home Depot, which allowed us to fully begin tank prototyping. Additionally, we learned how to communicate better as a team during this sprint, a skill that would serve us well in the future.\nWhat We Learned During this sprint we hit a few snags. In particular we were struggling to create a water-tight tank and we had some concerns about the PCB magnets we had ordered. It would take multiple iterations before we were able to successfully create a water-tight tank, and we had to wait to receive the PCB to see if our reservations would come to fruition.\nWe also learned how to communicate with each other and plan ahead. Using Notion to delegate tasks and keep track of notes was extremely helpful and at the end of the sprint we were more secure in our planning and more prepared to present for sprint two.\nNext Steps We decided the following would be deliverables for sprint two:\n Create a working, stain-proof ferrofluid tank Control and characterize the PCB magnets Complete magnet control software and begin working on animation software     Sprint Two \u0026uarr;   Sprint two info (talk about how it\u0026rsquo;s a check-in instead of a sprint)\nWhat We Did: Thing We Worked On: Info about thing\nOther Thing We Worked On: Info about other thing\nWhat We Learned: Based on this thing, we decided to do this instead of that.\n   Sprint Three \u0026uarr;   Sprint three was focused on getting a working MVP and creating viable backup plans. Our main goals were to:\n Brainstorm permanent magnet based display alternatives in case the ferrofluid tank wouldn\u0026rsquo;t be ready in time Design parts to hold everything together Finish up the animation software  Permanent-Magnet-Based Display Alternatives Since we were having so much trouble with the ferrofluid staining the tank, we needed a backup plan.\nKoi Pond One of the alternatives was a \u0026ldquo;Koi Pond\u0026rdquo; design, where the grid of electromagnets would lay flat and move a permanent magnet like a fish in a pond. A sketch of the concept is below:\nPillars Another alternative was a design we called \u0026ldquo;pillars\u0026rdquo;, where the electromagnets lift permanent magnets on pillars to create patterns.\nSpool Holder We created a 3D-printed part to hold the electromagnets in place against the tank. This took a couple of iterations to get right, since we had to hold everything securely while leaving room to route the wires. The two pieces are held together with screws and heat-set threaded inserts. Images of the parts are below:\nTank Breakthrough We managed to get a tank that wouldn\u0026rsquo;t leak or stain after thorough cleaning, so ferrofluid was a go. We were able to successfully test our hand-wound magnets with the ferrofluid tank, and it worked great.\nSoftware The software was almost done - animations could be created with an online tool, exported as keyframes, and turned into a file to put on an SD card for the microcontroller. Then, the microcontroller would interpolate animations and send commands to the PWM ICs on the controller boards.\nWhat We Learned This sprint was mostly grinding out various clearly defined tasks. We continued to improve communication, and managed to get our MVP working with a little bit of time to spare.\nEven though we didn\u0026rsquo;t end up needing to use them, we agreed that the backup plans were good to have, but we could\u0026rsquo;ve been more organized about figuring out proof-of-concepts.\nNext Steps In the final few days before our demonstration, we had a couple of goals in mind:\n Wire up all 16 magnets to the magnet controller board Create a set of animations to use on demo day  If we found extra time, we were also thinking of setting up a smaller power supply, since we had been using a benchtop one the whole time.\n Requirements\nYour final project site is required to contain the following elements.\nA high level summary description of the projectâ€™s objectives\n Review/edit as needed  A system diagram depicting the schematic relationships between all of the different subsystems comprising your final system.\n Review/let Lila know what edits to make  An account of how you spent your $250 budget. You must include all components and materials and their estimated costs (even if you obtained them for free somehow). Please note where something was obtained for free and cost is just your best estimate.\n Done  A detailed description of electrical design (circuit diagrams are appropriate) and any necessary analysis.\n Review/edit as needed (v possible i missed something)  A detailed description of your mechanical design (CAD images/renderings are appropriate) and any necessary analysis.\n Not sure how much is done  A detailed description of the firmware design with links to complete source code (github or other repository is helpful).\n Review/edit as needed  A detailed description of software design with links to complete source code (github or other repository is helpful). Please be sure to include a list of all external software dependencies (eg. OpenCV, Google Voice API, etc.)\n Were dependencies included? Review/edit as needed  Photos or videos of your final system in action.\n Added/consider adding more  ","permalink":"https://pietroglyph.github.io/ferrofluid-display/journey/","tags":null,"title":"Our Journey"},{"categories":null,"contents":"Contents:   Tank Magnets Controller Firmware Animation and Software Budget  Our system is comprised of mechanical, electrical, firmware, and software subsystems (click on diagram to enlarge image):\n\n\nTank \u0026uarr;  Our tank is comprised of two sheets of 10\u0026quot; by 12\u0026quot; glass with thickness 3/32\u0026quot; separated by a 1/4\u0026quot; acrylic rim. They are attached with epoxy.\nNext, the tank was cleaned thoroughly using ammonia and hot water and scrubbed with Goof Off.\n\nMagnets \u0026uarr;  The first plan for team FerroFish was to use PCB magnets. However, upon testing the PCB magnets we found that they were not viable for lifting and moving ferrofluid so the decision was made to create our own electromagnets.\nElectromagnets are created by wrapping wire around a ferrous core and applying a voltage to the wire, creating a current in the wire. The current induces a magnetic field and thus magnetizes the ferrous core - creating a magnet.\nThe equation for the strength of the field given by our electromagnets is below:\n$$B = \\frac{\\mu_oNI}{l}$$\nWhere $\\mu_o$ is the permittivity of free space, $N$ is the number of turns in the wire, $I$ is the current, and $l$ is the length of the solenoid.\nElectromagnets are more flexible than permanent magnets because they can be easily turned on and off by adjusting voltage. As a team we decided that electromagnets would provide the flexibility.\nCreating our Electromagnets We decided for cost purposes we would create our own electromagnets rather than buying premade ones. We calculated that 1000 turns would create a magnetic field strong enough to lift the ferrofluid.\nCreating our electromagnets was three main steps:\n 3D print spools for winding Create the magnets by winding the wire Soldering jumper cables onto the magnets so they can be used with controller boards  3D Printing Spools The spools were printeed in two parts and then glued together. These spools were then mounted onto the wiring rig so wire could be wound onto them.\nWinding the Wires On the rig for winding the magnets there is a counter that let the winder know when 1000 turns had been reached. Our goal for the magnet grid was a 4x4 grid, or 16 total magnets. Extra spools were printed in the event we had magnets break.\nSoldering the Magnets Once the magnets were wound, jumper cables were soldered onto the ends of the wires. The connection between the wire and the jumper cable was then wrapped in a protective shrink wrap to prevent shorts with other wires. A finished magnet is pictured below.\nUsing the Magnets We 3D printed a holder for our 4x4 magnet grid. This holder went through multiple iterations as we refined our tolerances and also created a way to hold the magnets to the tank. An image of all 16 magnets as well as the CAD for the final holder is below.\nFinal Take-Aways While originally we did not think that creating our own electromagnets would be cost or time effective, by the end of our project, it was apparent that it was our best option.\nCreating the magnets required a lot of patience and communication, but ultimately, it created a better end product as we were able to successfully make a magnet grid with them and lift the ferrofluid.\n\nMagnet Controller and Electronics \u0026uarr;  Our magnet controller is based off of the Applied Procrastination Electromagnet Control Board schematic. The main idea is to control an LED driver via I2C from your microcontroller to turn electromagnets on or off. The current out of the driver is not large enough to power the electromagnets, however, so we placed the signal through a Darlington transistor array. We included two sets header pins for our input signals and power rails, so we could chain together multiple boards, if we chose to expand the display.\nThe controller has 16 output pins, which connect to the 4 by 4 magnet array. It receives messages from the Arduino Uno, which can be programmed via Serial or with an SD card with animations preloaded (click to enlarge schematics).\n\nPullup resistors for I2C were selected based on Adafruit schematics for our LED driver. The capacitor values were chosen with help from Course Assistants Lauren and Corey as well as the Adafruit schematic.\nThe Arduino Mega was used due to an unfortunate frying of our Teensy 4.1 (may it rest in peace). The Arduino Mega has more memory than an Uno but has less memory and is slower than the Teensy.\n\n\nFirmware \u0026uarr;  As shown in our system diagram, a microcontroller plays back animations by sending commands over I2C to the PCA9685 PWM driver. This gives the firmware a few responsibilities:\n Read animations from the animation generator in an agreed-upon format from the SD card or serial, or read other debug commands from serial. Interpolate to create smooth fades between frames and space apart animation frames over time. Send commands to the PCA9685 over PWM.  To do this we have a simple state machine with states of \u0026ldquo;off\u0026rdquo;, \u0026ldquo;manual\u0026rdquo;, \u0026ldquo;SD\u0026rdquo;, and \u0026ldquo;serial\u0026rdquo;. The \u0026ldquo;off\u0026rdquo; state turns off all magnets and immediately transitions to \u0026ldquo;manual\u0026rdquo;; \u0026ldquo;manual\u0026rdquo; stays in manual and waits for commands over serial; \u0026ldquo;SD\u0026rdquo; reads animation frames from the SD card until it reaches the end of the file and then transitions to off; \u0026ldquo;serial\u0026rdquo; reads animation frames from serial until the serial buffer is empty for long enough for reads to time out. This state machine design means our code is fully interruptable by user commands, and it makes it very easy to add new commands and states, which was important during prototyping because we decided to add serial streaming when we had SD card problems and to better support our presentation at EXPO.\nThe \u0026ldquo;serial\u0026rdquo; and \u0026ldquo;SD\u0026rdquo; states use the same parsing code; because both the SD file object (FsFile) and the Arduino Serial object inherit from the Arduino Stream object, we can use the same code for parsing files and for parsing serial streams, as the formats are designed to be the same. We used a text-based format for instead of a binary format to avoid endianness and struct packing issues and to make our parsing code easy to modify and read by everyone on the team.\nThe firmware was written in C++17 and tries to do things in a C++ style where possible. This mostly means using constexpr instead of preprocessor macros for constants, if constexpr instead of preprocessor conditionals, std::array instead of C-style arrays, and C++-style includes of C standard library headers. We also define our own classes for managing the hardware. Their interfaces are equivalent so we can switch between different PWM drivers (e.g. between a simple PWM driver and an interpolating PWM driver). This was useful for initial debugging before we had brought up all the hardware, which helped a lot with integration.\nWe\u0026rsquo;ve used both an Arduino Uno and Mega and Teensy 4.1 and we ultimately needed to support all three because we prototyped with the Uno and initially used the Teensy until our perfboard failed and shorted the Teensy. This led us to switch to the Arduino Mega, which has a little bit more memory than the Uno (which we needed). The GCC toolchain for the Teensy includes all of the C++ standard template library, but the Arduino toolchian (avr-gcc) doesn\u0026rsquo;t, so we also include the avr_stl library and conditionally include it if we\u0026rsquo;re on an AVR-based board.\nThe portability of the code across microcontrollers was a very important part of having a smooth integration process for us because it enabled early prototyping without setting up the Teensy, and it allowed for a plan B when we had damaged our hardware.\nWe don\u0026rsquo;t use the Adafruit servo driver hardware (we have custom-designed PCBs), but we use the library that comes with it because it\u0026rsquo;s a complete and easy-to-use implementation of all the PCA9685\u0026rsquo;s I2C commands. We also use Bill Greiman\u0026rsquo;s SdFat library for reading from the SD card. We chose this over the Arduino-default one because it supports SDIO if the hardware has that capability (the Teensy 4.1 can do SD over SDIO instead of just SPI.)\n\nAnimation Generator The user needs to be able to easily draw animations. The microcontroller needs to have animations in a format it can read easily. This gives the animation software some responsibilities:\n Output the animations in a variety of formats: to a preview window, to a file, or output via serial. The animation file and serial formats need to agree between the microcontroller and the animation software, which means the people writing that software needed to plan this out Be able to switch between these output formats easily. We also anticipated having multiple ways to generate animations: programatically, from external drawing programs, or from splines. At the end of the day we only generated them from drawing programs, but this was an initial requirement that worked its way into our design.  To execute on this design we made the animation generator have a design with switchable \u0026ldquo;backends\u0026rdquo; and \u0026ldquo;frontends\u0026rdquo;:  (Click to enlarge)\nWe only ended up implemented the file-reading frontend, but we did have multiple backends that allowed us to view animations on the computer, stream over serial, and export to a file that could be loaded onto our SD card. We used the same format for streaming over serial and for writing to an output file, which allowed us to share a lot of code. The file format was, as mentioned above, a simple text-based format that we chose to avoid endianness and struct packing issues that can come with binary formants (unless you\u0026rsquo;re careful about their implementation.) This isn\u0026rsquo;t the most space-efficient format, but it\u0026rsquo;s very easy to inspect and the code is easy for others to read. The easy inspection of the file output and the visual preview backend made it easy to insure this code was correct long before we had our microcontroller firmware working, which made final integration much smoother. Because of this modular system it was very easy to add file export and serial capabilities when we needed them, which was made integration go more smoothly.\nWe used OpenCV to read and display images. The rest of our code just used C++17 standard library features and the CMake build system.\n\nBudget \u0026uarr;  Our total cost for our final display was $231.13. Below shows the breakdown by subsystem and item:\n   Tank Cost     Glass panes $6.30   Acrylic spacer $4*   Delrin holders $2*   Epoxy $10.94   Ferrofluid $31   Ammonia $1.78   Total $56.12       Magnets and Structures Cost     3D-printed pieces (\u0026lt; 200 g) $5*   Threaded inserts $6.93   M3 screws $5.33   Steel dowels $20.76   Magnet wire $10*   Total $48.02       Electronics (Mouser Part Number) Cost     Dupont socket/socket connectors (485-266) $11.85   Pin headers (649-1012937891601BLF) $3.99   Darlington transistor arrays (511-ULQ2801A) $16.25   LED Drivers (771-PCA9685BS118) $24.96   0.1 uF Capacitors (963-HMF212B7104KGHT) $2.80   10 uF Polar Capacitors (710-865080340001) $2.52   10k resistors (652-CR0603FX-1002ELF) $0.75   Total (including tax/shipping) $75.06       Boards Cost     Arduino Mega* $34.93   Custom controller boards $15   Perfboard $2*   Total $51.93    * Estimate (Obtained for Free)\n","permalink":"https://pietroglyph.github.io/ferrofluid-display/systems/","tags":null,"title":"Systems"},{"categories":null,"contents":"[[params.gallery.gallery_item ]] image = \u0026ldquo;images/banner.jpg\u0026rdquo;\n","permalink":"https://pietroglyph.github.io/ferrofluid-display/about/","tags":null,"title":"About"}]