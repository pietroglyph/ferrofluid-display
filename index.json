[{"categories":null,"contents":"Design Sprints The duration of the project was broken up into three two-week-long design sprints. At the end of each sprint, we presented our progress to the teaching team and our peers.\nContents:   Sprint One Sprint Two Sprint Three     Sprint One \u0026uarr;   Sprint One had three main objectives:\n Create a test tank Research magnets Ordering important materials and other important organizing tasks  Test Tank Creating the test tank had two subgoals: creating an \u0026ldquo;etch-a-sketch\u0026rdquo; where we were able to move metal shavings with an electromagnet and creating a water-tight tank.\nEtch-A-Sketch We were able to successfully create a small test tank that only had metal shavings in it. We used an electromagnet that had previously been purchased to prove that the metal shavings could be moved with an electromagnet. An image of the test tank is below.\nWater-Tight Tank Another goal with tank ideation was to begin thinking about what it would take to create a water-tight tank. At the start we knew that the finished product would have ferrofluid suspended in saline, so we had to be prepared to reach that goal.\nWhen we made the tank it was apparent that there were issues with leaking, a evidenced by salt build up on the outside of the tank from the saline inside. An image of the salt build up is below.\nAdditionally, we were unsure if we had successfully coated the tank to be hydrophobic. If the inside of the tank was not properly cleaned and coated, the ferrofluid would stick to the glass and stain it.\nMagnet Research We started this sprint by researching whether or not we should wind electromagnets by hand or buy them. We quickly ruled out buying electromagnets as it would be too expensive to buy the amount we wanted and we ruled out winding our own because of the time commitment it required.\nWound Electromagnet Research In our research, we realized that outright buying electromagnets would be too expensive. At the time we also discussed winding our own electromagnets, but ruled that out because of the time commitment and potentially having costs regarding wiring get out of hand.\nHowever, we did hand-wind a couple electromagnets to test if it was feasible. They were much weaker than our final magnets would be, but were an important test.\nDuring this sprint we settled on a different way to create an electromagnet: PCB coils.\nPCB Coil Electromagnets We designed and ordered PCB capable of creating an electromagnet. We believed our PCB electromagnets would have many advantages over traditional electromagnets: we could fit more \u0026ldquo;turns\u0026rdquo; in the wire in less space, power and control the magnets more easily, and we could cover more area of the tank. A picture of one of the finished magnet boards is below.\nWe designed and ordered the boards this sprint. Ideally they would work like a regular electromagnet - current would pass through the coils and magnetize a ferrous core in the middle of the turns. The plan was to cut small piece of a metal rod and slot them into the holes in the PCB.\nOrganization We made important organizational leaps during this sprint as well: we ordered the ferrofluid, we placed a Home Depot order with many crucial items, and we created a Notion board to delegate tasks.\nThe ferrofluid arrived at the very end of sprint one, so we were able to begin preliminary tests with it immediately. We ordered glass for a larger tank, epoxy, and a metal rod (ferrous core for the magnets) from Home Depot, which allowed us to fully begin tank prototyping. Additionally, we learned how to communicate better as a team during this sprint, a skill that would serve us well in the future.\nWhat We Learned During this sprint we hit a few snags. In particular we were struggling to create a water-tight tank and we had some concerns about the PCB magnets we had ordered. It would take multiple iterations before we were able to successfully create a water-tight tank, and we had to wait to receive the PCB to see if our reservations would come to fruition.\nWe also learned how to communicate with each other and plan ahead. Using Notion to delegate tasks and keep track of notes was extremely helpful and at the end of the sprint we were more secure in our planning and more prepared to present for sprint two.\nNext Steps We decided the following would be deliverables for sprint two:\n Create a working, stain-proof ferrofluid tank Control and characterize the PCB magnets Complete magnet control software and begin working on animation software     Sprint Two \u0026uarr;   Due to a general feeling of being overwhelmed across the campus, the second sprint review presentation for our class was instead changed to a simple design-review chat with the teaching team.\nSpring Goals and Progress Our initial goals for our second sprint were to:\n Finish construction of a leak- and stain-proof ferrofluid and water tank Finish assembly and characterization of the PCB electromagnets Design and order magnet controller PCBs Finish basic magnet control Arduino/Teensy firmware Begin animation generation code  Ferrofluid tank: At the end of our first sprint, our ferrofluid finally arrived. After conducting thorough research on how people online construct their ferrofluid tanks, we compiled a list of tips to constructing a stain-free ferrofluid tank:\n Use glass for the tank walls. If not available, then acrylic with a hydrophobic coating such as Rain-X may also work. Thoroughly clean tank walls, ideally with a harsh chemical such as ammonia or hydrochloric acid. After constructing the tank, fill it with brine and let it sit for at least 24 hours  Since we did not have access to sheets of glass, while having ready access to acrylic sheets via the Olin Shop, we started by constructing a small acrylic test tank. We also did not go thorugh the trouble of sourcing hydrochloric acid from the chemistry lab, so we ended up only following one and a half out of the three tips: letting the brine sit for 24 hours, and treating the sub-optimal acrylic with Rain-X. Thus, unfortunately but unsurprisingly, after treating our Acrylic tank with Rain-X and letting it wait 24 hours, we still found that it stained quite severly:\nThis did not surprise us, as once again we really were only following one and a half out of the three tips The first obvious next step from here was to construct a glass tank. After constructing the tank, treating with Rain-X, and letting it sit with brine for 24 hours, we added in the ferrofluid, and unfortunately found that it still stains: By this time, we had reached the end of our sprint. Thus, we failed to meet our sprint goal of having a leak- and stain-proof ferrofluid and water tank by the end of our second sprint. We only had one more thing to try next sprint: cleaning the glass using harsh chemicals.\nPCB electromagnets: During this spring, our PCB electromagnets had arrived. Our PCB electromagnets had ~60 turns per coil, per PCB. Naively, we thught that since magnetic field strenght was proportional to turn count, we would be able to just stack the PCBs until we reached enough field strength to move the ferrofluid. Thus, when the boards arrived, we soldered them together using our pre-made solder pads and a reflow oven:\n   Soldered PCB Stack PCB Coils holding paperclips          Unfortunately, our assumption about being able to stack the coils for additional strength did not hold true, so our PCB electromagnets proved too weak. Reality was, since field strength $B = \\frac{\\mu_0}{l}NI$, and really, if you have some $\\hat{r}$ resistance per turn, then $I = \\frac{V}{\\hat{r}N}$. Notice then, that when we multiply this $I$ with $N$, the $N$ and denominator of $I$ cancel out, meaning that turn count does not actually affect the strength of a magnet, since an increase in turn count would be counterracted by a corresponding decrease in current. With this limitation in mind, we now have thoughts on how to redesign our PCB electromagnets to achieve suitable strength for moving the ferrofluid, but we do not have enough time to actually go through with that redesign.\nIn conclusion, at the end of the sprint, while we had reached our goal of assembling and characterizing our PCB electromagnets, we have found that they are not strong enough, and we will need to look for an alternative for sourcing our electromagnets.\nMagnet Controller board: During this sprint, we designed, reviewed, and ordered our magnet controller board design. While our design is largely similar to that of other Ferrofluid tank projects online, the exact parts used are not available in the exact same package or SKUs, so we had to make substitutions of our own, and verify by comparing datasheets to make sure that our substitutions are suitable.\n   Controller PCB Design Render Fully Assembled Controller Board          With this, we met our sprint goal of finishing the design and ordering of magnet controller boards.\nLED test grid / Firmware: During this sprint, we constructed an LED test grid array that consisted of two 4x4 groups of LEDs that were individually addressable. This was to assist in developing a first past at the controlling firmware and testing LED addressing.\nAnimation code engine At the end of Sprint 2, we had finished a first path for both \u0026ldquo;frontend\u0026rdquo; and \u0026ldquo;backend\u0026rdquo; for the software. For the frontend, we had created a C++ program that will convert a set of PNG files to a simple file export with duty cycles corresponding to each pixel location. For the backend, a basic plotter was created.\nWebsite At the end of Sprint 2, we set up the basic layout and structure for our final website.\nWhat We Learned: At the end of Sprint 2, we were feeling very low: our tank was staining quite heavily, and our PCB electromagnets were not nearly strong enough. However, during this process we learned that if we want to build a stain-resistant ferrofluid tank, we really would have to treat the glass with harsh chemicals. At the same time, we learned that for an electromagnet coil made with the same material, the turn count ultimately does not affect the strength, as the effects are negated by the drop in current.\n   Sprint Three \u0026uarr;   Sprint three was focused on getting a working MVP and creating viable backup plans. Our main goals were to:\n Brainstorm permanent magnet based display alternatives in case the ferrofluid tank wouldn\u0026rsquo;t be ready in time Design parts to hold everything together Finish up the animation software  Permanent-Magnet-Based Display Alternatives Since we were having so much trouble with the ferrofluid staining the tank, we needed a backup plan.\nKoi Pond One of the alternatives was a \u0026ldquo;Koi Pond\u0026rdquo; design, where the grid of electromagnets would lay flat and move a permanent magnet like a fish in a pond. A sketch of the concept is below:\nPillars Another alternative was a design we called \u0026ldquo;pillars\u0026rdquo;, where the electromagnets lift permanent magnets on pillars to create patterns.\nSpool Holder We created a 3D-printed part to hold the electromagnets in place against the tank. This took a couple of iterations to get right, since we had to hold everything securely while leaving room to route the wires. The two pieces are held together with screws and heat-set threaded inserts. Images of the parts are below:\nTank Breakthrough We managed to get a tank that wouldn\u0026rsquo;t leak or stain after thorough cleaning, so ferrofluid was a go. This involved a lot of iteration with beakers that we tried cleaning with different combinations of ammonia and eventually Goof Off. When we got down a formula that seemed to work (ammona, scrub, Goof Off, scrub, let saline sit in beaker briefly), we tried it on the tank. This failed, which we think was because we weren\u0026rsquo;t able to scrub the tank enough or possibly because there was some contamination in one of the beakers we used to mix saline. We we-washed and re-scrubbed the tank and added saline and it worked. This became our final tank. We were able to successfully test our hand-wound magnets with the ferrofluid tank, and it worked great\u0026ndash;they were much easier to move than the iron powder.\nSoftware The software was almost done - animations could be created with an online tool, exported as keyframes, and turned into a file to put on an SD card for the microcontroller. Then, the microcontroller would interpolate animations and send commands to the PWM ICs on the controller boards.\nWhat We Learned This sprint was mostly grinding out various clearly defined tasks. We continued to improve communication, and managed to get our MVP working with a little bit of time to spare.\nEven though we didn\u0026rsquo;t end up needing to use them, we agreed that the backup plans were good to have, but we could\u0026rsquo;ve been more organized about figuring out proof-of-concepts.\nNext Steps In the final few days before our demonstration, we had a couple of goals in mind:\n Wire up all 16 magnets to the magnet controller board Create a set of animations to use on demo day  If we found extra time, we were also thinking of setting up a smaller power supply, since we had been using a benchtop one the whole time.\nDemo Day Deliverables For demo day our goals were as follows:\n Wire all 16 magnets to the controller board Create animations for the demo  We were able to successfully wire up all of the magnets, create a stand to hold the magnets and other components behind the tank, and load animations onto an SD card and play them on the tank. Our system was in full working order for demo day and a video of the working tank is below. A video of a working animation is below. video\n ","permalink":"https://pietroglyph.github.io/ferrofluid-display/journey/","tags":null,"title":"Our Journey"},{"categories":null,"contents":"Contents:   Tank Magnets Controller Firmware Animation and Software Budget   Our system is comprised of mechanical, electrical, firmware, and software subsystems (click on diagram to enlarge image):\n\nA complete image of the final system can be seen here:\n   Front Back          \nTank \u0026uarr;  Our tank is comprised of two sheets of 10\u0026quot; by 12\u0026quot; glass with thickness 3/32\u0026quot; separated by a 1/4\u0026quot; acrylic rim. They are attached with epoxy.\nNext, the tank was cleaned extremely thoroughly using ammonia and hot water and scrubbed with Goof Off. Without this cleaning process, the ferrofluid would stain the glass severly, leaving the glass a brown-tinted mess.\n\nMagnets \u0026uarr;  The first plan for team FerroFish was to use PCB magnets. However, upon testing the PCB magnets, we found that they were not viable for lifting and moving ferrofluid, so the decision was made to create our own electromagnets.\nElectromagnets are created by wrapping wire around a ferrous core and applying a voltage to the wire, creating a current in the wire. The current induces a magnetic field and thus magnetizes the ferrous core — creating a magnet.\nThe equation for the strength of the field given by our electromagnets is below:\n$$B = \\frac{\\mu_oNI}{l}$$\nWhere $\\mu_o$ is the permittivity of free space, $N$ is the number of turns in the wire, $I$ is the current, and $l$ is the length of the solenoid.\nElectromagnets are more flexible than permanent magnets because they can be easily turned on and off by adjusting voltage. As a team, we decided that electromagnets would provide the flexibility we needed.\nCreating our Electromagnets We decided for cost purposes that we would create our own electromagnets rather than buying premade ones. We calculated that 1000 turns would create a magnetic field strong enough to lift the ferrofluid with reasonable current.\nCreating our electromagnets was three main steps:\n 3D print spools for winding Create the magnets by winding the wire Soldering jumper cables onto the magnets so they can be used with controller boards  3D Printing Spools The spools were printed in two parts and then glued together. These spools were then mounted onto the wiring rig, so wire could be wound onto them.\nWinding the Wires On the rig for winding the magnets, there is a counter that let the winder know when 1000 turns had been reached. Our goal for the magnet grid was a 4x4 grid, or 16 total magnets. Extra spools were printed in the event we had magnets break.\nSoldering the Magnets Once the magnets were wound, jumper cables were soldered onto the ends of the wires. The connection between the wire and the jumper cable was then wrapped in a heat shrink wrap to prevent shorts with other wires. A finished magnet is pictured below.\nUsing the Magnets We 3D printed a holder for our 4x4 magnet grid. This holder went through multiple iterations as we refined our tolerances and also created a way to hold the magnets to the tank. An image of all 16 magnets as well as the CAD for the final holder is below.\nFinal Take-Aways While originally we did not think that creating our own electromagnets would be cost or time effective, by the end of our project, it was apparent that it was our best option.\nCreating the magnets required a lot of patience and communication, but ultimately, it created a better end product as we were able to successfully make a magnet grid with them and lift the ferrofluid.\n\nMagnet Controller and Electronics \u0026uarr;  Our magnet controller is based off of the Applied Procrastination Electromagnet Control Board schematic. The main idea is to control an LED driver via I2C from your microcontroller to turn electromagnets on or off. The current out of the driver is not large enough to power the electromagnets, however, so we placed the signal through a Darlington transistor array. We included two sets of header pins for our input signals and power rails, so we could chain together multiple boards, if we chose to expand the display.\nThe controller has 16 output pins, which connect to the 4 by 4 magnet array. It receives I2C messages from the Arduino Mega, which can be programmed via Serial or with an SD card with animations preloaded (click to enlarge schematics).\n\nPullup resistors for I2C were selected based on Adafruit schematics for our LED driver. The capacitor values were chosen with help from Course Assistants Lauren and Corey as well as the Adafruit schematic.\nThe Arduino Mega was used due to an unfortunate frying of our Teensy 4.1 (may it rest in peace). The Arduino Mega has more memory than an Uno but has less memory and is slower than the Teensy.\n\n\nFirmware \u0026uarr;  As shown in our system diagram, a microcontroller plays back animations by sending commands over I2C to the PCA9685 PWM driver. This gives the firmware a few responsibilities:\n Read animations from the animation generator in an agreed-upon format from the SD card or serial, or read other debug commands from serial. Interpolate to create smooth fades between frames and space apart animation frames over time. Send commands to the PCA9685 over PWM.  To do this we have a simple state machine with states of \u0026ldquo;off\u0026rdquo;, \u0026ldquo;manual\u0026rdquo;, \u0026ldquo;SD\u0026rdquo;, and \u0026ldquo;serial\u0026rdquo;. The \u0026ldquo;off\u0026rdquo; state turns off all magnets and immediately transitions to \u0026ldquo;manual\u0026rdquo;; \u0026ldquo;manual\u0026rdquo; stays in manual and waits for commands over serial; \u0026ldquo;SD\u0026rdquo; reads animation frames from the SD card until it reaches the end of the file and then transitions to off; \u0026ldquo;serial\u0026rdquo; reads animation frames from serial until the serial buffer is empty for long enough for reads to time out. This state machine design means our code is fully interruptable by user commands, and it makes it very easy to add new commands and states, which was important during prototyping because we decided to add serial streaming when we had SD card problems and to better support our presentation at EXPO.\nThe \u0026ldquo;serial\u0026rdquo; and \u0026ldquo;SD\u0026rdquo; states use the same parsing code; because both the SD file object (FsFile) and the Arduino Serial object inherit from the Arduino Stream object, we can use the same code for parsing files and for parsing serial streams, as the formats are designed to be the same. We used a text-based format for instead of a binary format to avoid endianness and struct packing issues and to make our parsing code easy to modify and read by everyone on the team.\nThe firmware was written in C++17 and tries to do things in a C++ style where possible. This mostly means using constexpr instead of preprocessor macros for constants, if constexpr instead of preprocessor conditionals, std::array instead of C-style arrays, and C++-style includes of C standard library headers. We also define our own classes for managing the hardware. Their interfaces are equivalent so we can switch between different PWM drivers (e.g. between a simple PWM driver and an interpolating PWM driver). This was useful for initial debugging before we had brought up all the hardware, which helped a lot with integration.\nWe\u0026rsquo;ve used both an Arduino Uno and Mega and Teensy 4.1 and we ultimately needed to support all three because we prototyped with the Uno and initially used the Teensy until our perfboard failed and shorted the Teensy. This led us to switch to the Arduino Mega, which has a little bit more memory than the Uno (which we needed). The GCC toolchain for the Teensy includes all of the C++ standard template library, but the Arduino toolchian (avr-gcc) doesn\u0026rsquo;t, so we also include the avr_stl library and conditionally include it if we\u0026rsquo;re on an AVR-based board.\nThe portability of the code across microcontrollers was a very important part of having a smooth integration process for us because it enabled early prototyping without setting up the Teensy, and it allowed for a plan B when we had damaged our hardware.\nWe don\u0026rsquo;t use the Adafruit servo driver hardware (we have custom-designed PCBs), but we use the library that comes with it because it\u0026rsquo;s a complete and easy-to-use implementation of all the PCA9685\u0026rsquo;s I2C commands. We also use Bill Greiman\u0026rsquo;s SdFat library for reading from the SD card. We chose this over the Arduino-default one because it supports SDIO if the hardware has that capability (the Teensy 4.1 can do SD over SDIO instead of just SPI.)\n\nAnimation Generator The user needs to be able to easily draw animations. The microcontroller needs to have animations in a format it can read easily. This gives the animation software some responsibilities:\n Output the animations in a variety of formats: to a preview window, to a file, or output via serial. The animation file and serial formats need to agree between the microcontroller and the animation software, which means the people writing that software needed to plan this out Be able to switch between these output formats easily. We also anticipated having multiple ways to generate animations: programatically, from external drawing programs, or from splines. At the end of the day we only generated them from drawing programs, but this was an initial requirement that worked its way into our design.  To execute on this design we made the animation generator have a design with switchable \u0026ldquo;backends\u0026rdquo; and \u0026ldquo;frontends\u0026rdquo;:  (Click to enlarge)\nWe only ended up implemented the file-reading frontend, but we did have multiple backends that allowed us to view animations on the computer, stream over serial, and export to a file that could be loaded onto our SD card. We used the same format for streaming over serial and for writing to an output file, which allowed us to share a lot of code. The file format was, as mentioned above, a simple text-based format that we chose to avoid endianness and struct packing issues that can come with binary formants (unless you\u0026rsquo;re careful about their implementation.) This isn\u0026rsquo;t the most space-efficient format, but it\u0026rsquo;s very easy to inspect and the code is easy for others to read. The easy inspection of the file output and the visual preview backend made it easy to insure this code was correct long before we had our microcontroller firmware working, which made final integration much smoother. Because of this modular system it was very easy to add file export and serial capabilities when we needed them, which was made integration go more smoothly.\nWe used OpenCV to read and display images. The rest of our code just used C++17 standard library features and the CMake build system.\n\nBudget \u0026uarr;  Our total cost for our final display was $231.13. Below shows the breakdown by subsystem and item:\n   Tank Cost     Glass panes $6.30   Acrylic spacer $4*   Delrin holders $2*   Epoxy $10.94   Ferrofluid $31   Ammonia $1.78   Total $56.12       Magnets and Structures Cost     3D-printed pieces (\u0026lt; 200 g) $5*   Threaded inserts $6.93   M3 screws $5.33   Steel dowels $20.76   Magnet wire $10*   Total $48.02       Electronics (Mouser Part Number) Cost     Dupont socket/socket connectors (485-266) $11.85   Pin headers (649-1012937891601BLF) $3.99   Darlington transistor arrays (511-ULQ2801A) $16.25   LED Drivers (771-PCA9685BS118) $24.96   0.1 uF Capacitors (963-HMF212B7104KGHT) $2.80   10 uF Polar Capacitors (710-865080340001) $2.52   10k resistors (652-CR0603FX-1002ELF) $0.75   Total (including tax/shipping) $75.06       Boards Cost     Arduino Mega* $34.93   Custom controller boards $15   Perfboard $2*   Total $51.93    * Estimate (Obtained for Free)\n","permalink":"https://pietroglyph.github.io/ferrofluid-display/systems/","tags":null,"title":"Systems"},{"categories":null,"contents":"table,tr,th,td { border: 0px solid transparent !important; } th,td { text-align: center; } th,td { width: 500px !important; } .entry-content  :not(.alignwide):not(.alignfull):not(.alignleft):not(.alignright):not(.is-style-wide) { max-width: 85% !important; }           Marissa Klein Lila Smith Jacob Smilg Declan Freeman-Gleason Bill Fan    Marissa is a senior at Wellesley College (‘22) and is majoring in astrophysics. Her interests include observational astronomy, CubeSat manufacturing, and repairing retro video game consoles. Currently, she is applying to graduate school to pursue a Ph.D in aerospace engineering.\n Lila is a sophomore at Olin College (‘24) and is majoring in Electrical and Computer Engineering. Her interests include hardware design and integration. Outside of class, she enjoys rock climbing and growing edible mushrooms.\n Jacob is a sophomore at Olin College (‘24) and is majoring in Electrical and Computer Engineering. He is interested in assistive technology and electrical hardware design. In his free time, he likes to play music and make things.\n Declan is a sophomore at Olin College (‘24) and is majoring in Engineering with a concentration in Robotics. His interests include mathematics and systems-level programming. He also enjoys reading, playing music, and baking bread.\n Bill is a sophomore at Olin College (‘24) and is majoring in Engineering with a concentration in Robotics. His main interests are in work that lies at the intersection between robotics, math, and physics, but also enjoys software development as well as mechanical and electrical design. Outside of work, he can be found rock climbing, playing music, or reading.\n   ","permalink":"https://pietroglyph.github.io/ferrofluid-display/about/","tags":null,"title":"About"}]