[{"categories":null,"contents":"Design Sprints The duration of the project was broken up into three two-week-long design sprints. At the end of each sprint, we presented our progress to the teaching team and our peers.\nContents:   Sprint One Sprint Two Sprint Three     Sprint One \u0026uarr;   Sprint one info\nWhat We Did: Thing We Worked On: Info about thing\nOther Thing We Worked On: Info about other thing\nWhat We Learned: Based on this thing, we decided to do this instead of that.\n   Sprint Two \u0026uarr;   Sprint two info (talk about how it\u0026rsquo;s a check-in instead of a sprint)\nWhat We Did: Thing We Worked On: Info about thing\nOther Thing We Worked On: Info about other thing\nWhat We Learned: Based on this thing, we decided to do this instead of that.\n   Sprint Three \u0026uarr;   Sprint three summary\nWhat We Did: Thing We Worked On: Info about thing\nOther Thing We Worked On: Info about other thing\nWhat We Learned: Based on this thing, we decided to do this instead of that.\n Requirements\nYour final project site is required to contain the following elements.\nA high level summary description of the projectâ€™s objectives\n Review/edit as needed  A system diagram depicting the schematic relationships between all of the different subsystems comprising your final system.\n Review/let Lila know what edits to make  An account of how you spent your $250 budget. You must include all components and materials and their estimated costs (even if you obtained them for free somehow). Please note where something was obtained for free and cost is just your best estimate.\n Done  A detailed description of electrical design (circuit diagrams are appropriate) and any necessary analysis.\n Review/edit as needed (v possible i missed something)  A detailed description of your mechanical design (CAD images/renderings are appropriate) and any necessary analysis.\n Not sure how much is done  A detailed description of the firmware design with links to complete source code (github or other repository is helpful).\n Review/edit as needed  A detailed description of software design with links to complete source code (github or other repository is helpful). Please be sure to include a list of all external software dependencies (eg. OpenCV, Google Voice API, etc.)\n Were dependencies included? Review/edit as needed  Photos or videos of your final system in action.\n Added/consider adding more  ","permalink":"https://pietroglyph.github.io/ferrofluid-display/journey/","tags":null,"title":"Our Journey"},{"categories":null,"contents":"Contents:   Tank Magnets Controller Firmware Animation and Software Budget  Our system is comprised of mechanical, electrical, firmware, and software subsystems (click on diagram to enlarge image):\n\n\nTank Our tank is comprised of two sheets of 10\u0026quot; by 12\u0026quot; glass with thickness 3/32\u0026quot; separated by a 1/4\u0026quot; acrylic rim. They are attached with epoxy.\nNext, the tank was cleaned thoroughly using ammonia and hot water and scrubbed with Goof Off.\n\nMagnets The first plan for team FerroFish was to use PCB magnets. However, upon testing the PCB magnets we found that they were not viable for lifting and moving ferrofluid so the decision was made to create our own electromagnets.\nElectromagnets are created by wrapping wire around a ferrous core and applying a voltage to the wire, creating a current in the wire. The current induces a magnetic field and thus magnetizes the ferrous core - creating a magnet.\nThe equation for the strength of the field given by our electromagnets is below:\n$$B = \\frac{\\mu_oNI}{l}$$\nWhere $\\mu_o$ is the permittivity of free space, $N$ is the number of turns in the wire, $I$ is the current, and $l$ is the length of the solenoid.\nElectromagnets are more flexible than permanent magnets because they can be easily turned on and off by adjusting voltage. As a team we decided that electromagnets would provide the flexibility.\nCreating our Electromagnets We decided for cost purposes we would create our own electromagnets rather than buying premade ones. We calculated that 1000 turns would create a magnetic field strong enough to lift the ferrofluid.\nCreating our electromagnets was three main steps:\n 3D print spools for winding Create the magnets by winding the wire Soldering jumper cables onto the magnets so they can be used with controller boards  3D Printing Spools The spools were printeed in two parts and then glued together. These spools were then mounted onto the wiring rig so wire could be wound onto them.\nWinding the Wires On the rig for winding the magnets there is a counter that let the winder know when 1000 turns had been reached. Our goal for the magnet grid was a 4x4 grid, or 16 total magnets. Extra spools were printed in the event we had magnets break.\nSoldering the Magnets Once the magnets were wound, jumper cables were soldered onto the ends of the wires. The connection between the wire and the jumper cable was then wrapped in a protective shrink wrap to prevent shorts with other wires. A finished magnet is pictured below.\nUsing the Magnets We 3D printed a holder for our 4x4 magnet grid. This holder went through multiple iterations as we refined our tolerances and also created a way to hold the magnets to the tank. An image of all 16 magnets as well as the CAD for the final holder is below.\nFinal Take-Aways While originally we did not think that creating our own electromagnets would be cost or time effective, by the end of our project, it was apparent that it was our best option.\nCreating the magnets required a lot of patience and communication, but ultimately, it created a better end product as we were able to successfully make a magnet grid with them and lift the ferrofluid.\n\nController and Electronics Our magnet controller is based off of the Applied Procrastination Electromagnet Control Board schematic. The main idea is to control an LED driver via I2C from your microcontroller to turn electromagnets on or off. The current out of the driver is not large enough to power the electromagnets, however, so we placed the signal through a Darlington transistor array. We included two sets header pins for our input signals and power rails, so we could chain together multiple boards, if we chose to expand the display.\nPullup resistors for I2C were selected based on Adafruit schematics for our LED driver. The capacitor values were chosen with help from Course Assistants Lauren and Corey as well as the Adafruit schematic.\nThe Arduino Mega was used due to an unfortunate frying of our Teensy 4.1 (may it rest in peace). The Arduino Mega has more memory than an Uno but has less memory and is slower than the Teensy.\n\nThe controller has 16 output pins, which connect to the 4 by 4 magnet array. It receives messages from the Arduino Uno, which can be programmed via Serial or with an SD card with animations preloaded.\n\n\nFirmware As shown in our system diagram, a microcontroller plays back animations by sending commands over I2C to the PCA9685 PWM driver. This gives the firmware a few responsibilities:\n Read animations from the animation generator in an agreed-upon format from the SD card or serial, or read other debug commands from serial. Interpolate to create smooth fades between frames and space apart animation frames over time. Send commands to the PCA9685 over PWM.  To do this we have a simple state machine with states of \u0026ldquo;off\u0026rdquo;, \u0026ldquo;manual\u0026rdquo;, \u0026ldquo;SD\u0026rdquo;, and \u0026ldquo;serial\u0026rdquo;. The \u0026ldquo;off\u0026rdquo; state turns off all magnets and immediately transitions to \u0026ldquo;manual\u0026rdquo;; \u0026ldquo;manual\u0026rdquo; stays in manual and waits for commands over serial; \u0026ldquo;SD\u0026rdquo; reads animation frames from the SD card until it reaches the end of the file and then transitions to off; \u0026ldquo;serial\u0026rdquo; reads animation frames from serial until the serial buffer is empty for long enough for reads to time out. This state machine design means our code is fully interruptable by user commands, and it makes it very easy to add new commands and states, which was important during prototyping because we decided to add serial streaming when we had SD card problems and to better support our presentation at EXPO.\nThe \u0026ldquo;serial\u0026rdquo; and \u0026ldquo;SD\u0026rdquo; states use the same parsing code; because both the SD file object (FsFile) and the Arduino Serial object inherit from the Arduino Stream object, we can use the same code for parsing files and for parsing serial streams, as the formats are designed to be the same. We used a text-based format for instead of a binary format to avoid endianness and struct packing issues and to make our parsing code easy to modify and read by everyone on the team.\nThe firmware was written in C++17 and tries to do things in a C++ style where possible. This mostly means using constexpr instead of preprocessor macros for constants, if constexpr instead of preprocessor conditionals, std::array instead of C-style arrays, and C++-style includes of C standard library headers. We also define our own classes for managing the hardware. Their interfaces are equivalent so we can switch between different PWM drivers (e.g. between a simple PWM driver and an interpolating PWM driver). This was useful for initial debugging before we had brought up all the hardware, which helped a lot with integration.\nWe\u0026rsquo;ve used both an Arduino Uno and Mega and Teensy 4.1 and we ultimately needed to support all three because we prototyped with the Uno and initially used the Teensy until our perfboard failed and shorted the Teensy. This led us to switch to the Arduino Mega, which has a little bit more memory than the Uno (which we needed). The GCC toolchain for the Teensy includes all of the C++ standard template library, but the Arduino toolchian (avr-gcc) doesn\u0026rsquo;t, so we also include the avr_stl library and conditionally include it if we\u0026rsquo;re on an AVR-based board.\nThe portability of the code across microcontrollers was a very important part of having a smooth integration process for us because it enabled early prototyping without setting up the Teensy, and it allowed for a plan B when we had damaged our hardware.\nWe don\u0026rsquo;t use the Adafruit servo driver hardware (we have custom-designed PCBs), but we use the library that comes with it because it\u0026rsquo;s a complete and easy-to-use implementation of all the PCA9685\u0026rsquo;s I2C commands. We also use Bill Greiman\u0026rsquo;s SdFat library for reading from the SD card. We chose this over the Arduino-default one because it supports SDIO if the hardware has that capability (the Teensy 4.1 can do SD over SDIO instead of just SPI.)\n\nAnimation Generator The user needs to be able to easily draw animations. The microcontroller needs to have animations in a format it can read easily. This gives the animation software some responsibilities:\n Output the animations in a variety of formats: to a preview window, to a file, or output via serial. The animation file and serial formats need to agree between the microcontroller and the animation software, which means the people writing that software needed to plan this out Be able to switch between these output formats easily. We also anticipated having multiple ways to generate animations: programatically, from external drawing programs, or from splines. At the end of the day we only generated them from drawing programs, but this was an initial requirement that worked its way into our design.  To execute on this design we made the animation generator have a design with switchable \u0026ldquo;backends\u0026rdquo; and \u0026ldquo;frontends\u0026rdquo;:  (Click to enlarge)\nWe only ended up implemented the file-reading frontend, but we did have multiple backends that allowed us to view animations on the computer, stream over serial, and export to a file that could be loaded onto our SD card. We used the same format for streaming over serial and for writing to an output file, which allowed us to share a lot of code. The file format was, as mentioned above, a simple text-based format that we chose to avoid endianness and struct packing issues that can come with binary formants (unless you\u0026rsquo;re careful about their implementation.) This isn\u0026rsquo;t the most space-efficient format, but it\u0026rsquo;s very easy to inspect and the code is easy for others to read. The easy inspection of the file output and the visual preview backend made it easy to insure this code was correct long before we had our microcontroller firmware working, which made final integration much smoother. Because of this modular system it was very easy to add file export and serial capabilities when we needed them, which was made integration go more smoothly.\nWe used OpenCV to read and display images. The rest of our code just used C++17 standard library features and the CMake build system.\n\nBudget Our total cost for our final display was $231.13. Below shows the breakdown by subsystem and item:\n   Tank Cost     Glass panes $6.30   Acrylic spacer $4*   Delrin holders $2*   Epoxy $10.94   Ferrofluid $31   Ammonia $1.78   Total $56.12       Magnets and Structures Cost     3D-printed pieces (\u0026lt; 200 g) $5*   Threaded inserts $6.93   M3 screws $5.33   Steel dowels $20.76   Magnet wire $10*   Total $48.02       Electronics (Mouser Part Number) Cost     Dupont socket/socket connectors (485-266) $11.85   Pin headers (649-1012937891601BLF) $3.99   Darlington transistor arrays (511-ULQ2801A) $16.25   LED Drivers (771-PCA9685BS118) $24.96   0.1 uF Capacitors (963-HMF212B7104KGHT) $2.80   10 uF Polar Capacitors (710-865080340001) $2.52   10k resistors (652-CR0603FX-1002ELF) $0.75   Total (including tax/shipping) $75.06       Boards Cost     Arduino Mega* $34.93   Custom controller boards $15   Perfboard $2*   Total $51.93    * Estimate (Obtained for Free)\n","permalink":"https://pietroglyph.github.io/ferrofluid-display/systems/","tags":null,"title":"Systems"},{"categories":null,"contents":"[[params.gallery.gallery_item ]] image = \u0026ldquo;images/banner.jpg\u0026rdquo;\n","permalink":"https://pietroglyph.github.io/ferrofluid-display/about/","tags":null,"title":"About"}]